apply plugin: 'com.android.application'

android {
    compileSdkVersion project.ANDROID_BUILD_SDK_VERSION as int
    buildToolsVersion project.ANDROID_BUILD_TOOLS_VERSION
    //关闭Android Studio的PNG合法性检查,将Eclipse项目导入到Android studio 中 很多点9图出现问题解决方法：
    // 用来关闭Android Studio的PNG合法性检查的，直接不让它检查。
    aaptOptions.cruncherEnabled = false
    aaptOptions.useNewCruncher = false
    defaultConfig {
        applicationId project.APPLICATION_ID // lib项目不需要配置这一项
        versionCode project.VERSION_CODE as int
        versionName project.VERSION_NAME
        minSdkVersion project.ANDROID_BUILD_MIN_SDK_VERSION as int
        targetSdkVersion project.ANDROID_BUILD_TARGET_SDK_VERSION as int
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }
    signingConfigs {// 自动化打包配置
        config {
            keyAlias project.KEY_ALIAS
            keyPassword project.KEY_PASSWORD
            storeFile file('../base_application.jks')
            storePassword project.STORE_PASSWORD
        }
    }
    buildTypes {
        //android代码编译成apk后如果没有进行任何防护措施是很容易被反编译的，并且反编译的结果甚至就是简单的源码，
        // 带来的损失可大可小。幸好，AndroidStudio提供编译代码加密，即ProGuard。
        release {
            minifyEnabled true//是否进行代码混淆
            /*proguardFiles 代码加密原则 有两个文件对，getDefaultProguardFile(‘proguard-android.txt’)表示默认文件，
            这个文件是sdk自带的，有一些通用的配置；但是如果apk需要更加严格的加密，我们可以在’proguard-rules.pro’文件中进行更加详尽的配置。*/
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt'
            //是否清理无用资源
            shrinkResources true
            //是否启用zipAlign压缩
            zipAlignEnabled true
            pseudoLocalesEnabled true//是否在APK中生成伪语言环境，帮助国际化的东西，一般使用的不多
            signingConfig signingConfigs.config//设置签名信息
        }
        debug {
            minifyEnabled true//true：启用混淆,false:不启用
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            shrinkResources true
            zipAlignEnabled true
            pseudoLocalesEnabled true
            signingConfig signingConfigs.config
            debuggable true//是否支持断点调试
            jniDebuggable true//是否可以调试NDK代码
            renderscriptDebuggable true//是否开启渲染脚本就是一些c写的渲染方法
        }
    }
    //配置目录指向
    //配置 jniLibs.srcDirs = ['libs']，可以在Android studio的Android视图下生成jniLibs文件夹，
    // 可以方便我们存放jar包和库文件
    sourceSets {
        main {
            jniLibs.srcDirs = ['libs']
        }
    }
    packagingOptions {//打包时的相关配置
        //pickFirsts做用是 当有重复文件时 打包会报错 这样配置会使用第一个匹配的文件打包进入apk
        // 表示当apk中有重复的META-INF目录下有重复的LICENSE文件时 只用第一个 这样打包就不会报错
        pickFirsts = ['META-INF/LICENSE']
        //merges何必 当出现重复文件时 合并重复的文件 然后打包入apk
        //这个是有默认值得 merges = [] 这样会把默默认值去掉 所以我们用下面这种方式 在默认值后添加
        merge 'META-INF/LICENSE'
        //这个是在同时使用butterknife、dagger2做的一个处理。同理，遇到类似的问题，只要根据gradle的提示，做类似处理即可。
        exclude 'META-INF/services/javax.annotation.processing.Processor'
    }
    //程序在编译的时候会检查lint，有任何错误提示会停止build，我们可以关闭这个开关
    lintOptions {
        abortOnError false //即使报错也不会停止打包
        checkReleaseBuilds false //打包release版本的时候进行检测
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'androidx.appcompat:appcompat:1.1.0'
    implementation 'androidx.constraintlayout:constraintlayout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test:runner:1.2.0'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'
}
